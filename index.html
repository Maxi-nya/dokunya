<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dokunyan (Prototype)</title>
  <style>
    body { font-family: sans-serif; background-color: #f4f4f4; padding: 20px; }
    table { border-collapse: collapse; margin: 0 auto; }
    th, td {
      border: 2px solid #555;
      padding: 10px;
      width: 120px;
      height: 100px;
      text-align: center;
      vertical-align: middle;
      position: relative;
    }
    input { width: 100px; text-align: center; }
    .correct { background-color: #b6e3a4; font-weight: bold; }
    .error { background-color: #fbb; }
    .category-cell { background-color: #ddd; font-weight: bold; }
    .autocomplete-items {
      position: absolute; top: 100%; left: 0; right: 0; z-index: 99;
      background-color: white; border: 1px solid #ccc; max-height: 120px; overflow-y: auto;
    }
    .autocomplete-items div { padding: 8px; cursor: pointer; }
    .autocomplete-items div:hover { background-color: #e9e9e9; }
  </style>
</head>
<body>
  <h1 style="text-align:center">DOKUNYAN (Prototype)</h1>
  <div id="dailyInfo" style="text-align:center; margin: 10px 0; font-weight: bold;"></div>
  <h3 style="text-align:center">Daily puzzle: combine monster attributes to guess correctly. No repeats!</h3>
  <div id="game" style="text-align:center"></div>

  <script>
    const categories = {
      type: "Monster Type",
      element: "Monster Element",
      weaknesses: "Weakness",
      main_map: "Main Map"
    };

    const usedMonsters = new Set();

    function getDailySeed(date = new Date()) {
      const year = date.getUTCFullYear();
      const month = String(date.getUTCMonth() + 1).padStart(2, '0');
      const day = String(date.getUTCDate()).padStart(2, '0');
      return `${year}${month}${day}`;
    }

    function seededRandom(seed) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < seed.length; i++) {
        h ^= seed.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return () => {
        h += h << 13; h ^= h >>> 7;
        h += h << 3; h ^= h >>> 17;
        h += h << 5;
        return (h >>> 0) / 4294967295;
      };
    }

    function uniqueValues(data, key) {
      const values = new Set();
      data.forEach(m => {
        const val = m[key];
        if (Array.isArray(val)) val.forEach(v => values.add(v));
        else if (val) values.add(val);
      });
      return Array.from(values);
    }

    function pickValues(rng, values, count) {
      const shuffled = values.slice().sort(() => rng() - 0.5);
      return shuffled.slice(0, count);
    }

    function autocomplete(input, td, monsterData) {
      input.addEventListener("input", function () {
        let val = this.value;
        closeAllLists();
        if (!val) return false;
        const list = document.createElement("div");
        list.setAttribute("class", "autocomplete-items");
        td.appendChild(list);
        monsterData.forEach(monster => {
          if (monster.name.toLowerCase().startsWith(val.toLowerCase())) {
            const item = document.createElement("div");
            item.innerText = monster.name;
            item.addEventListener("click", function () {
              input.value = monster.name;
              closeAllLists();
              input.dispatchEvent(new Event("change"));
            });
            list.appendChild(item);
          }
        });
      });

      function closeAllLists() {
        document.querySelectorAll(".autocomplete-items").forEach(l => l.remove());
      }

      document.addEventListener("click", function (e) {
        if (e.target !== input) closeAllLists();
      });
    }

    function buildGrid(monsters, rowCat, colCat, rowVals, colVals) {
      const gameDiv = document.getElementById("game");
      gameDiv.innerHTML = "";
      const table = document.createElement("table");

      const header = document.createElement("tr");
      header.appendChild(document.createElement("th"));
      colVals.forEach(col => {
        const th = document.createElement("th");
        th.className = "category-cell";
        th.innerText = col;
        header.appendChild(th);
      });
      table.appendChild(header);

      rowVals.forEach(row => {
        const tr = document.createElement("tr");
        const th = document.createElement("th");
        th.className = "category-cell";
        th.innerText = row;
        tr.appendChild(th);

        colVals.forEach(col => {
          const td = document.createElement("td");
          const input = document.createElement("input");
          autocomplete(input, td, monsters);

          input.addEventListener("change", () => {
            const name = input.value.trim();
            const monster = monsters.find(m => m.name.toLowerCase() === name.toLowerCase());
            if (!monster) {
              input.className = "error";
              return;
            }
            const valRow = monster[rowCat];
            const valCol = monster[colCat];
            const matchRow = Array.isArray(valRow) ? valRow.includes(row) : valRow === row;
            const matchCol = Array.isArray(valCol) ? valCol.includes(col) : valCol === col;

            if (matchRow && matchCol && !usedMonsters.has(monster.name)) {
              usedMonsters.add(monster.name);
              input.className = "correct";
              input.disabled = true;
            } else {
              input.className = "error";
            }
          });

          td.appendChild(input);
          tr.appendChild(td);
        });

        table.appendChild(tr);
      });

      gameDiv.appendChild(table);
    }

    fetch("data/monsters.json")
      .then(res => res.json())
      .then(monsters => {
        const seed = getDailySeed();
        const rng = seededRandom(seed);

        const categoryKeys = Object.keys(categories).sort(() => rng() - 0.5);
        const rowCat = categoryKeys[0];
        const colCat = categoryKeys[1];

        // Construir comboMap solo con monstruos que tengan valores v√°lidos en rowCat y colCat
        const comboMap = new Map();

        monsters.forEach(m => {
          const valRow = m[rowCat];
          const valCol = m[colCat];
          const okRow = valRow && (Array.isArray(valRow) ? valRow.length > 0 : true);
          const okCol = valCol && (Array.isArray(valCol) ? valCol.length > 0 : true);

          if (!okRow || !okCol) return; // saltar monstruos sin valores v√°lidos en alguna categor√≠a

          const rows = Array.isArray(valRow) ? valRow : [valRow];
          const cols = Array.isArray(valCol) ? valCol : [valCol];

          rows.forEach(r => {
            cols.forEach(c => {
              const key = `${r}|${c}`;
              if (!comboMap.has(key)) comboMap.set(key, []);
              comboMap.get(key).push(m);
            });
          });
        });

        const allRows = [...new Set(Array.from(comboMap.keys(), k => k.split('|')[0]))];
        const allCols = [...new Set(Array.from(comboMap.keys(), k => k.split('|')[1]))];

        function findValidGrid(rng, rowVals, colVals, comboMap, size) {
          const shuffledRows = rowVals.slice().sort(() => rng() - 0.5);
          const shuffledCols = colVals.slice().sort(() => rng() - 0.5);

          for (let rStart = 0; rStart <= shuffledRows.length - size; rStart++) {
            for (let cStart = 0; cStart <= shuffledCols.length - size; cStart++) {
              const candidateRows = shuffledRows.slice(rStart, rStart + size);
              const candidateCols = shuffledCols.slice(cStart, cStart + size);

              const allExist = candidateRows.every(r =>
                candidateCols.every(c => comboMap.has(`${r}|${c}`))
              );

              if (allExist) return { rows: candidateRows, cols: candidateCols };
            }
          }
          return null;
        }

        let grid = findValidGrid(rng, allRows, allCols, comboMap, 3);
        if (!grid) grid = findValidGrid(rng, allRows, allCols, comboMap, 2);

        if (!grid) {
          document.getElementById("game").innerText = "‚ùå No se pudo generar una grilla v√°lida con los datos actuales.";
          return;
        }

        const { rows: rowVals, cols: colVals } = grid;

        // Filtrar monstruos v√°lidos para la grilla
        const validMonsters = monsters.filter(m => {
          const valRow = m[rowCat];
          const valCol = m[colCat];
          const rows = Array.isArray(valRow) ? valRow : [valRow];
          const cols = Array.isArray(valCol) ? valCol : [valCol];
          return rows.some(r => rowVals.includes(r)) && cols.some(c => colVals.includes(c));
        });

        document.getElementById("dailyInfo").innerText =
          `üóìÔ∏è Puzzle del d√≠a: ${seed.slice(0,4)}-${seed.slice(4,6)}-${seed.slice(6)} ‚Äì Categor√≠as: ${categories[rowCat]} √ó ${categories[colCat]}`;

        buildGrid(validMonsters, rowCat, colCat, rowVals, colVals);
      })
      .catch(err => {
        console.error("Failed to load JSON", err);
        document.getElementById("game").innerText = "‚ùå Error cargando datos de monstruos.";
      });
  </script>
</body>
</html>
