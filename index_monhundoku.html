<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Monhundoku Prototype</title>
  <style>
    body {
      font-family: sans-serif;
      background-color: #f4f4f4;
      padding: 20px;
    }
    table {
      border-collapse: collapse;
      margin: 0 auto;
    }
    th, td {
      border: 2px solid #555;
      padding: 10px;
      width: 120px;
      height: 100px;
      text-align: center;
      vertical-align: middle;
      position: relative;
    }
    input {
      width: 100px;
      text-align: center;
    }
    .correct {
      background-color: #b6e3a4;
      font-weight: bold;
    }
    .error {
      background-color: #fbb;
    }
    .category-cell {
      background-color: #ddd;
      font-weight: bold;
    }
    .autocomplete-items {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      z-index: 99;
      background-color: white;
      border: 1px solid #ccc;
      max-height: 120px;
      overflow-y: auto;
    }
    .autocomplete-items div {
      padding: 8px;
      cursor: pointer;
    }
    .autocomplete-items div:hover {
      background-color: #e9e9e9;
    }
    .tooltip {
      display: inline-block;
      position: relative;
      cursor: help;
    }
    .tooltip:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 100%;
      top: 50%;
      transform: translateY(-50%);
      background: #333;
      color: #fff;
      padding: 5px;
      border-radius: 4px;
      white-space: nowrap;
      z-index: 999;
    }
  </style>
</head>
<body>
  <h1 style="text-align:center">Monhundoku (Prototype)</h1>
  <h3 style="text-align:center">Match the monster with the correct row and column categories. No repeats allowed.</h3>
  <div id="game" style="text-align:center"></div>

  <script>
    const categoryLabels = {
      type: "Wyvern Type",
      element: "Monster Element",
      weaknesses: "Elemental Weakness",
      habitat: "Habitat",
      main_map: "Main Map",
      origin_game: "Origin Game",
      is_elder: "Elder Dragon",
      evolves_from: "Evolves From"
    };

    const categoryExplanations = {
      weaknesses: "Uses latest known weaknesses from most recent game appearance. Top two hitzone-based elements only.",
      evolves_from: "Used when a monster is considered the 'final form' of a smaller monster (like Velociprey → Velocidrome).",
      habitat: "Specific area where the monster is most commonly found.",
      main_map: "General environment (e.g., Desert, Forest, Volcano)."
    };

    const categories = Object.keys(categoryLabels);
    const usedMonsters = new Set();

    const gameDiv = document.getElementById("game");
    const table = document.createElement("table");

    const randomSample = (arr, n) => arr.sort(() => 0.5 - Math.random()).slice(0, n);
    const rowCategories = randomSample(categories, 3);
    const colCategories = randomSample(categories.filter(c => !rowCategories.includes(c)), 3);

    const rowHeader = document.createElement("tr");
    rowHeader.appendChild(document.createElement("th"));
    colCategories.forEach(cat => {
      const th = document.createElement("th");
      th.className = "category-cell";
      th.innerHTML = categoryLabels[cat] + (categoryExplanations[cat] ? ` <span class='tooltip' data-tooltip='${categoryExplanations[cat]}'>ℹ️</span>` : "");
      rowHeader.appendChild(th);
    });
    table.appendChild(rowHeader);

    function autocomplete(input, td) {
      input.addEventListener("input", function () {
        let val = this.value;
        closeAllLists();
        if (!val) return false;

        const list = document.createElement("div");
        list.setAttribute("class", "autocomplete-items");
        td.appendChild(list);

        monsterData.forEach(monster => {
          if (monster.name.toLowerCase().startsWith(val.toLowerCase())) {
            const item = document.createElement("div");
            item.innerText = monster.name;
            item.addEventListener("click", function () {
              input.value = monster.name;
              closeAllLists();
              input.dispatchEvent(new Event("change"));
            });
            list.appendChild(item);
          }
        });
      });

      function closeAllLists() {
        const lists = document.querySelectorAll(".autocomplete-items");
        lists.forEach(l => l.remove());
      }

      document.addEventListener("click", function (e) {
        if (e.target !== input) closeAllLists();
      });
    }

    function buildGrid() {
      rowCategories.forEach(rowCat => {
        const row = document.createElement("tr");
        const th = document.createElement("th");
        th.className = "category-cell";
        th.innerHTML = categoryLabels[rowCat] + (categoryExplanations[rowCat] ? ` <span class='tooltip' data-tooltip='${categoryExplanations[rowCat]}'>ℹ️</span>` : "");
        row.appendChild(th);

        colCategories.forEach(colCat => {
          const td = document.createElement("td");
          const input = document.createElement("input");
          autocomplete(input, td);

          input.addEventListener("change", () => {
            const name = input.value.trim();
            const monster = monsterData.find(m => m.name.toLowerCase() === name.toLowerCase());

            if (!monster) {
              input.className = "error";
              return;
            }

            const rowValue = monster[rowCat];
            const colValue = monster[colCat];

            const matchesRow = Array.isArray(rowValue)
              ? rowValue.includes(categoryLabels[rowCat])
              : rowValue === categoryLabels[rowCat] || rowValue === true;

            const matchesCol = Array.isArray(colValue)
              ? colValue.includes(categoryLabels[colCat])
              : colValue === categoryLabels[colCat] || colValue === true;

            if (matchesRow && matchesCol && !usedMonsters.has(monster.name)) {
              usedMonsters.add(monster.name);
              input.className = "correct";
              input.disabled = true;
            } else {
              input.className = "error";
            }
          });

          td.appendChild(input);
          row.appendChild(td);
        });

        table.appendChild(row);
      });

      gameDiv.appendChild(table);
    }

    let monsterData = [];

    fetch("monsters.json")
      .then(res => res.json())
      .then(data => {
        monsterData = data;
        buildGrid();
      })
      .catch(err => console.error("Failed to load monsters.json", err));
  </script>
</body>
</html>
